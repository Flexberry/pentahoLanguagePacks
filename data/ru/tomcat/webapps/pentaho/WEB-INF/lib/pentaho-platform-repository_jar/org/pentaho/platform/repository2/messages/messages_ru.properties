# Copyright 2008 - 2010 Pentaho Corporation.  All rights reserved.
# This program is free software; you can redistribute it and/or modify it under the 
# terms of the GNU General Public License, version 2 as published by the Free Software 
# Foundation.
#
# You should have received a copy of the GNU General Public License along with this 
# program; if not, you can obtain a copy at http://www.gnu.org/licenses/gpl-2.0.html 
# or from the Free Software Foundation, Inc., 
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.

AbstractRepositoryLifecycleManager.ERROR_0001_STARTUP_NOT_CALLED=Запуск должен быть вызван первым
MondrianRepositoryLifecycleManager.USER_0001_VER_COMMENT_MONDRIAN=[system] создана папка mondrian
PdiRepositoryLifecycleManager.USER_0001_VER_COMMENT_PDI=[system] Создана папка pdi
PdiRepositoryLifecycleManager.USER_0002_VER_COMMENT_DATABASES=[system] создана папка базы данных
PdiRepositoryLifecycleManager.USER_0003_VER_COMMENT_SLAVESERVERS=[system] Создана папка slaveServers
PdiRepositoryLifecycleManager.USER_0004_CLUSTERSCHEMAS=[system] Создана папка clusterSchemas
PdiRepositoryLifecycleManager.USER_0005_PARTITIONSCHEMAS=[system] Создана папка partitionSchemas
PentahoJcrTemplate.ERROR_0001_ACCESS_DENIED=Доступ запрещен к этим данным
DefaultRepositoryLifecycleManager.USER_0001_VER_COMMENT_PENTAHO_ROOT=[system] создана корневая папка системы pentaho
DefaultRepositoryLifecycleManager.USER_0002_VER_COMMENT_TENANT_ROOT=[system] created tenant root folder<TRANSLATE ME>
DefaultRepositoryLifecycleManager.USER_0003_TENANT_PUBLIC=[system] created tenant public folder<TRANSLATE ME>
DefaultRepositoryLifecycleManager.USER_0004_TENANT_HOME=[system] created tenant home folder<TRANSLATE ME>
DefaultRepositoryLifecycleManager.USER_0005_TENANT_ETC=[system] created tenant etc folder<TRANSLATE ME>
DefaultRepositoryLifecycleManager.USER_0006_USER_HOME=[system] Создана домашняя папка пользователя
DefaultUnifiedRepositoryWebService.ERROR_0001_NO_IMPL=no IUnifiedRepository implementation<TRANSLATE ME>
ExceptionLoggingDecorator.lockException=lock error while {0}\n\nReference number: {1}<TRANSLATE ME>
ExceptionLoggingDecorator.transactionException=transaction error while {0}\n\nReference number: {1}<TRANSLATE ME>
ExceptionLoggingDecorator.accessDeniedException=Доступ запрещен пока {0}\n\nReference количество: {1}
ExceptionLoggingDecorator.referentialIntegrityException=referential integrity error while {0}; (file {1} is being referenced by file(s) {2})\n\nReference number: {3}<TRANSLATE ME>
ExceptionLoggingDecorator.fileExistsException=file already exists error while {0}; path is "{1}"\n\nReference number: {2}<TRANSLATE ME>
ExceptionLoggingDecorator.malformedNameException=malformed name error while {0}; invalid name: "{1}"\n\nReference number: {2}<TRANSLATE ME>
ExceptionLoggingDecorator.canUnlockFile=determining ability to unlock file with id "{0}"<TRANSLATE ME>
ExceptionLoggingDecorator.createFile=Создание файла с именем "{0}"
ExceptionLoggingDecorator.createFolder=Создание папки с именем "{0}"
ExceptionLoggingDecorator.deleteFile=Удаление файла с идентификатором "{0}"
ExceptionLoggingDecorator.deleteFileAtVersion=Удаление файла с идентификатором «{0}» и идентификатором версии «{1}»
ExceptionLoggingDecorator.generalException=exception while {0}\n\nReference number: {1}<TRANSLATE ME>
ExceptionLoggingDecorator.getAcl=Получение ACL для файла с идентификатором "{0}"
ExceptionLoggingDecorator.getChildren=getting children for folder with id "{0}"<TRANSLATE ME>
ExceptionLoggingDecorator.getData=получение данных для файла с идентификатором "{0}"
ExceptionLoggingDecorator.getDataInBatch=получение данных для файлов
ExceptionLoggingDecorator.getDataAtVersion=получение данных для файла с идентификатором "{0}" и идентификатором версии "{0}"
ExceptionLoggingDecorator.getDeletedFiles=получение всех удаленных файлов
ExceptionLoggingDecorator.getDeletedFilesInFolder=getting deleted files in folder with path "{0}"<TRANSLATE ME>
ExceptionLoggingDecorator.getEffectiveAces=getting effective ACEs for file with id "{0}"<TRANSLATE ME>
ExceptionLoggingDecorator.getFile=Получение файла, который имеет путь "{0}"
ExceptionLoggingDecorator.getReferrers=получение ссылок для файла с идентификатором "{0}"
ExceptionLoggingDecorator.getTree=getting tree rooted at path "{0}"<TRANSLATE ME>
ExceptionLoggingDecorator.getFileAtVersion=Получение файла с идентификатором "{0}" и идентификатором версии "{1}"
ExceptionLoggingDecorator.getFileById=получение файла с идентификатором "{0}"
ExceptionLoggingDecorator.getVersionSummaries=получение истории версий для файла с идентификатором "{0}"
ExceptionLoggingDecorator.getVersionSummary=получение информации о версии для файла с идентификатором "{0}" и идентификатором версии "{1}"
ExceptionLoggingDecorator.getVersionSummaryInBatch=получение информации о версии для файлов
ExceptionLoggingDecorator.hasAccess=Определение доступа для файла,который имеет путь "{0}"
ExceptionLoggingDecorator.lockFile=Блокировка файла с идентификатором "{0}"
ExceptionLoggingDecorator.moveFile=Перемещение файла с идентификатором "{0}" в путь назначения "{1}"
ExceptionLoggingDecorator.copyFile=Копирование файла с идентификатором "{0}" в путь назначения "{1}"
ExceptionLoggingDecorator.referenceNumber=Базовый номер: {0}
ExceptionLoggingDecorator.restoreFileAtVersion=Восстановление файла с идентификатором файла "{0}" и идентификатором версии "{1}"
ExceptionLoggingDecorator.undeleteFile=восстановление файлов с идентификатором "{0}"
ExceptionLoggingDecorator.unlockFile=Разблокировать файл с идентификатором "{0}"
ExceptionLoggingDecorator.updateAcl=Обновление ACL для файла с идентификатором "{0}"
ExceptionLoggingDecorator.updateFile=Обновление файла с идентификатором "{0}"
ExceptionLoggingDecorator.getReservedChars=Получение зарезервированных символов
ExceptionLoggingDecorator.getAvailableLocalesForFile=Получение доступных мест для файла "{0}"
ExceptionLoggingDecorator.getLocalePropertiesForFile=Получение свойств локали для файла "{0}"
ExceptionLoggingDecorator.setLocalePropertiesForFile=Установка свойств локали для файла "{0}"
ExceptionLoggingDecorator.deleteLocalePropertiesForFile=Удаление свойств локали для файла "{0}"
FileImporter.WARN_0001_NO_EXT=Пропуск {0}, поскольку файл не имеет расширения
FileImporter.WARN_0002_NO_CONVERTER=Пропуск {0}, потому что конвертер  для расширения не найден
FileImporter.WARN_0003_IOEXCEPTION=пропуск {0} из-за исключения
FileImporter.WARN_0004_NO_MIME=skipping {0} because no MIME type found for extension<TRANSLATE ME>
FileImporter.USER_0001_IMPORT_COUNT=imported {0} of {1} files ({2} ms)<TRANSLATE ME>
FileImporter.ERROR_0001_ERROR_RETRIEVING_FILES=Ошибка при получении файлов
FileImporter.ERROR_0002_ERROR_IMPORTING_FILE=Ошибка импорта файла {1}: {0}
JackrabbitRepositoryFileAclDao.ERROR_0001_NODE_NOT_FOUND=Узел с id [{0}] не найден
JackrabbitRepositoryFileAclDao.ERROR_0002_POLICY=most likely due to calling readAclById before calling createAcl<TRANSLATE ME>
JackrabbitRepositoryFileAclDao.USER_0001_VER_COMMENT_CREATED_ACL=[system] создан ACL
JackrabbitRepositoryFileAclDao.USER_0002_VER_COMMENT_UPDATED_ACL=[system]  ACL обновлен
JcrRepositoryFileDao.ERROR_0001_NO_TRANSFORMER=no transformer found<TRANSLATE ME>
JcrRepositoryFileDao.ERROR_0002_CANNOT_OVERWRITE_FILE_WITH_FOLDER=Невозможно переписать файл в папку
JcrRepositoryFileDao.ERROR_0003_ILLEGAL_DEST_PATH=Незаконный путь назначения
JcrRepositoryFileDao.ERROR_0004_PARENT_MUST_EXIST=immediate parent folder of destination path must exist<TRANSLATE ME>
JcrRepositoryFileDao.ERROR_0005_PARENT_MUST_BE_FOLDER=Прямой родительский путь назначения не является папкой
JcrRepositoryFileDao.USER_0001_VER_COMMENT_ADD_FOLDER=[system] Добавлена дочерняя папка '' {0} '' в {1}
JcrRepositoryFileDao.USER_0002_VER_COMMENT_ADD_FILE=[system]Добавлен дочерний файл '' {0} '' в {1}
JcrRepositoryFileDao.USER_0003_VER_COMMENT_LOCK_FILE=[system] Заблокированный файл с id = {0}
JcrRepositoryFileDao.LOCALE_0001_UPDATE_PROPERTIES=Обновить локальные свойства для идентификатора= {0}
JcrRepositoryFileDao.LOCALE_0002_DELETE_PROPERTIES=удалить свойства локали для идентификатора={0}
JcrRepositoryFileUtils.ERROR_0001_MISSING_EXT=Имена файлов должны иметь расширение
JcrRepositoryFileUtils.USER_0001_VER_COMMENT_UNLOCK_FILE=[system] разблокированный файл с ID={0}
XmlAdapter.ERROR_0001_MARSHAL=error marshalling {0} to {1}<TRANSLATE ME>
XmlAdapter.ERROR_0002_UNMARSHAL=error unmarshalling {0} to {1}<TRANSLATE ME>
DefaultDeleteHelper.ERROR_0001_PATH_NOT_FOUND=Не получается определить исходный идентификатор родительской папки, поскольку путь исходной родительской папки не существует
DefaultDeleteHelper.ERROR_0002_NOT_CLEAN=this should have been cleaned up on undelete or permanent delete<TRANSLATE ME>
JcrRepositoryFileDao.ERROR_0006_ACCESS_DENIED_DELETE=Доступ запрещен при удалении файла с идентификатором [{0}]
DefaultUnifiedRepository.ERROR_0001_ACCESS_DENIED_UPDATE_ACL=Доступ запрещен при обновлении разрешения на доступ к файлу с идентификатором [ {0} ]
JcrRepositoryFileUtils.WARN_0001_NPE_FROM_CR=«Получение NPE из репозитория контента»
AclNodeHelper.ERROR_0001_ROOT_FOLDER_NOT_AVAILABLE=Root folder {0} not available. Using default {1} instead<TRANSLATE ME>
AclNodeHelper.WARN_0001_REMOVE_ACL_NODE= Удаление узла ACL:
AclNodeHelper.WARN_0002_REMOVE_ACL_STORE= Удаление хранилища ACL: {0}
